struct HtmlColorRaw<'a> {
    name: &'a str,
    ctor: &'a str
}

/**

    Generates file with the named html colors.

    File line format: "aliceblue rgb(240, 248, 255)". Comments and empty lines are allowed.

    # Generates:
        * constants for each color, e.g, "const INDIANRED: Rgb = rgb(x, y, z);"
        * array with each html color
*/
pub fn generate() {
    const HTML_NAMES_PATH: &str = "contrib/html-color-names.txt";

    let content = std::fs::read_to_string(HTML_NAMES_PATH).unwrap();
    let parsed_colors = parse_html_colors(&content);

    println!("cargo:rerun-if-changed={HTML_NAMES_PATH}");

    let gen_path = std::path::Path::new(
        &std::env::var_os("OUT_DIR").unwrap()
    ).join(
        format!("{HTML_NAMES_PATH}.rs")
    );

    let mut gen_code = String::with_capacity(150 * 2 * 50);
    gen_code += "// This file is generated by build script, do not modify it!\n\n";
    separate_const_for_each_color(&mut gen_code, &parsed_colors);
    gen_code += "\n";
    array_with_all_colors(&mut gen_code, &parsed_colors);

    std::fs::create_dir_all(gen_path.parent().unwrap()).unwrap();
    std::fs::write(gen_path, gen_code).unwrap();
}

fn parse_html_colors(content: &str) -> Vec<HtmlColorRaw> {
    let mut colors = vec![];

    for line in content.lines() {
        // File line format: "aliceblue rgb(240, 248, 255)"
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let mut split = line.splitn(2, ' ');
        let name = split.next().unwrap().trim();
        let ctor = split.next().unwrap().trim();

        colors.push(HtmlColorRaw { name, ctor });
    }

    // Modify it when adding new entries to the file.
    assert_eq!(colors.len(), 147);
    colors
}

fn separate_const_for_each_color(buff: &mut String, colors: &[HtmlColorRaw]) {
    for HtmlColorRaw { name, ctor } in colors {
        *buff += &format!(
            "pub const {}: Rgb = {};\n",
            name.to_ascii_uppercase(), ctor
        );
    }
}

fn array_with_all_colors(buff: &mut String, colors: &[HtmlColorRaw]) {
    *buff += &format!(
        "pub const HTML_NAMED_COLORS: [HtmlColor; {}] = [\n",
        colors.len()
    );
    for HtmlColorRaw { name, ctor } in colors {
        *buff += &format!("\t(\"{name}\", {ctor}),\n");
    }
    *buff += "];\n";
}
