use std::fmt::Write as _;

fn main() {
    generate_html_colors();
}

struct HtmlColorRaw<'a> {
    name: &'a str,
    ctor: &'a str,
}

/**
    Generates file with the named html colors.

    File line format: "aliceblue rgb(240, 248, 255)". Comments and empty lines are allowed.

    # Generates:
        * constants for each color, e.g, "const INDIANRED: Rgb = rgb(x, y, z);"
        * array with each html color
*/
#[allow(clippy::missing_panics_doc)]
pub fn generate_html_colors() {
    const HTML_NAMES_PATH: &str = "contrib/html-color-names.txt";

    let content =
        std::fs::read_to_string(std::path::Path::new("..").join(HTML_NAMES_PATH)).unwrap();
    let parsed_colors = parse_html_colors(&content);

    println!("cargo:rerun-if-changed={HTML_NAMES_PATH}");

    let gen_path = std::path::Path::new(&std::env::var_os("OUT_DIR").unwrap())
        .join(format!("{HTML_NAMES_PATH}.rs"));

    // number of html colors * occurence * generated string length
    let mut gen_code = String::with_capacity(150 * 2 * 50);

    gen_code += "// This file is generated by build script, do not modify it!\n\n";
    separate_const_for_each_color(&mut gen_code, &parsed_colors);
    gen_code += "\n";
    array_with_all_colors(&mut gen_code, &parsed_colors);

    std::fs::create_dir_all(gen_path.parent().unwrap()).unwrap();
    std::fs::write(gen_path, gen_code).unwrap();
}

fn parse_html_colors(content: &'_ str) -> Vec<HtmlColorRaw<'_>> {
    let mut colors = vec![];

    for line in content.lines() {
        // File line format: "aliceblue rgb(240, 248, 255)"
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let mut split = line.splitn(2, ' ');
        let name = split.next().unwrap().trim();
        let ctor = split.next().unwrap().trim();

        colors.push(HtmlColorRaw { name, ctor });
    }
    colors
}

fn separate_const_for_each_color(buff: &mut String, colors: &[HtmlColorRaw]) {
    for HtmlColorRaw { name, ctor } in colors {
        let _ = writeln!(
            buff,
            "pub const {}: Rgb = {};",
            name.to_ascii_uppercase(),
            ctor
        );
    }
}

fn array_with_all_colors(buff: &mut String, colors: &[HtmlColorRaw]) {
    let _ = writeln!(buff, "pub const COLORS: [HtmlColor; {}] = [", colors.len());
    for HtmlColorRaw { name, ctor } in colors {
        let _ = writeln!(buff, "\tHtmlColor {{name: \"{name}\", color: {ctor}}},");
    }
    *buff += "];\n";
}
